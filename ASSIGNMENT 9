#include <bits/stdc++.h>
using namespace std;

/*-------------------------------------------
   BFS
-------------------------------------------*/
void BFS(int start, vector<vector<int>>& adj) {
    int n = adj.size();
    vector<bool> vis(n, false);
    queue<int> q;

    vis[start] = true;
    q.push(start);

    cout << "BFS: ";
    while(!q.empty()) {
        int u = q.front(); q.pop();
        cout << u << " ";
        for(int v : adj[u]) {
            if(!vis[v]) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
    cout << endl;
}

/*-------------------------------------------
   DFS
-------------------------------------------*/
void dfsUtil(int u, vector<vector<int>>& adj, vector<bool>& vis) {
    vis[u] = true;
    cout << u << " ";
    for(int v : adj[u])
        if(!vis[v]) dfsUtil(v, adj, vis);
}

void DFS(int start, vector<vector<int>>& adj) {
    int n = adj.size();
    vector<bool> vis(n, false);
    cout << "DFS: ";
    dfsUtil(start, adj, vis);
    cout << endl;
}

/*-------------------------------------------
   Kruskal MST
-------------------------------------------*/
struct DSU {
    vector<int> parent, rank;
    DSU(int n) { parent.resize(n); rank.resize(n, 0); iota(parent.begin(), parent.end(), 0); }
    int find(int x){ return parent[x] == x ? x : parent[x] = find(parent[x]); }
    bool unite(int a, int b){
        a = find(a); b = find(b);
        if(a == b) return false;
        if(rank[a] < rank[b]) swap(a, b);
        parent[b] = a;
        if(rank[a] == rank[b]) rank[a]++;
        return true;
    }
};

int Kruskal(int n, vector<tuple<int,int,int>>& edges) {
    sort(edges.begin(), edges.end(), [](auto &a, auto &b){
        return get<2>(a) < get<2>(b);
    });

    DSU dsu(n);
    int mst_cost = 0;

    cout << "Kruskal MST Edges:\n";
    for(auto &e : edges) {
        int u, v, w;
        tie(u, v, w) = e;
        if(dsu.unite(u, v)) {
            mst_cost += w;
            cout << u << " - " << v << " : " << w << endl;
        }
    }
    return mst_cost;
}

/*-------------------------------------------
   Primâ€™s MST
-------------------------------------------*/
int Prim(int n, vector<vector<pair<int,int>>>& adj) {
    vector<bool> used(n, false);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    pq.push({0, 0}); // {weight, node}
    int mst_cost = 0;

    cout << "Prim MST Edges:\n";

    while(!pq.empty()) {
        auto [w, u] = pq.top();
        pq.pop();
        if(used[u]) continue;

        used[u] = true;
        mst_cost += w;

        if(w != 0)
            cout << "Take Node " << u << " with weight " << w << endl;

        for(auto &[v, wt] : adj[u])
            if(!used[v]) pq.push({wt, v});
    }
    return mst_cost;
}

/*-------------------------------------------
   Dijkstra (general graph)
-------------------------------------------*/
vector<int> Dijkstra(vector<vector<pair<int,int>>>& adj, int src) {
    int n = adj.size();
    vector<int> dist(n, INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    dist[src] = 0;
    pq.push({0, src});

    while(!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if(d != dist[u]) continue;

        for(auto &p : adj[u]) {
            int v = p.first, w = p.second;
            if(dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}

/*-------------------------------------------
   Connected Components Count
-------------------------------------------*/
int connectedComponents(int n, vector<vector<int>>& adj) {
    vector<bool> vis(n, false);
    int count = 0;

    for(int i = 0; i < n; i++) {
        if(!vis[i]) {
            count++;
            queue<int> q;
            q.push(i);
            vis[i] = true;

            while(!q.empty()) {
                int u = q.front(); q.pop();
                for(int v : adj[u])
                    if(!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                    }
            }
        }
    }
    return count;
}

/*-------------------------------------------
   Shortest Path in Grid (Dijkstra)
-------------------------------------------*/
int shortestPathGrid(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();

    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

    dist[0][0] = grid[0][0];
    pq.push({grid[0][0], 0, 0});

    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};

    while(!pq.empty()) {
        auto curr = pq.top(); pq.pop();
        int d = curr[0], r = curr[1], c = curr[2];

        if(d != dist[r][c]) continue;

        for(auto &dir : dirs) {
            int nr = r + dir[0], nc = c + dir[1];
            if(nr>=0 && nr<m && nc>=0 && nc<n) {
                int nd = d + grid[nr][nc];
                if(nd < dist[nr][nc]) {
                    dist[nr][nc] = nd;
                    pq.push({nd, nr, nc});
                }
            }
        }
    }

    return dist[m-1][n-1];
}

/*-------------------------------------------
   Network Delay Time
-------------------------------------------*/
int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int,int>>> adj(n+1);
    for(auto &t : times)
        adj[t[0]].push_back({t[1], t[2]});

    vector<int> dist(n+1, INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    dist[k] = 0;
    pq.push({0, k});

    while(!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if(d != dist[u]) continue;

        for(auto &p : adj[u]) {
            int v = p.first, w = p.second;
            if(dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    int ans = *max_element(dist.begin()+1, dist.end());
    return ans == INT_MAX ? -1 : ans;
}

/*-------------------------------------------
   Number of Islands
-------------------------------------------*/
void dfsIsland(int r, int c, vector<vector<int>>& g) {
    int m = g.size(), n = g[0].size();
    if(r<0 || r>=m || c<0 || c>=n || g[r][c] == 0) return;
    g[r][c] = 0;

    dfsIsland(r+1, c, g);
    dfsIsland(r-1, c, g);
    dfsIsland(r, c+1, g);
    dfsIsland(r, c-1, g);
}

int numIslands(vector<vector<int>> grid) {
    int m = grid.size(), n = grid[0].size();
    int count = 0;

    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
            if(grid[i][j] == 1) {
                count++;
                dfsIsland(i, j, grid);
            }
    return count;
}

/*-------------------------------------------
   MAIN (Demo)
-------------------------------------------*/
int main() {
    cout << "Graph Algorithms Implemented Successfully!\n";
    cout << "Use functions individually for testing.\n";
    return 0;
}
